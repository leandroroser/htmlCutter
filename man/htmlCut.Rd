% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/htmlCut.R
\name{htmlCut}
\alias{htmlCut}
\title{Cut an HTML file into its constitutive elements, creating an SQLite database with tags, contents, attributes and values}
\usage{
htmlCut(my_file, sqlite.export = TRUE, db.name = "out.sqlite",
  single.tags = c("\\\\!", "link", "META", "meta", "img", "input", "br",
  "base", "col", "command", "embed", "hr", "param", "source"),
  overwrite = TRUE, recursive = FALSE, minString = TRUE)
}
\arguments{
\item{my_file}{Input HTML file.}

\item{sqlite.export}{Export into an sqlite database? Default TRUE.
The case FALSE returns the results as data.frames.}

\item{db.name}{Name of the output SQLite database.}

\item{single.tags}{Tags that must be considered as single (not closed).}

\item{overwrite}{Overwrite if the output database exists.}

\item{recursive}{Create a database showing all the nested elements within a tag
in an explicit fashion? Default FALSE (only one level of recursion is allowed).}

\item{minString}{Use substitution within a tag with the codes \{<ID>\}, where the ID's are the
name of the sons? Default TRUE.}
}
\description{
This program creates a series of SQLite tables dividing into pieces the content of an HTML file.
To find tags, the program uses a nested set model algorithm and regular expressions. Tags nested within a father tag
are substituted by the characters "\{<ID>\}", where ID is the number of the son tag.
In the default action, the substitution is not recursive, i.e., only one level of nesting is
allowed. This saves space in the database avoiding repeated elements.
A given tag can be recovered at its initial state with the function tagExplicit.
}
\author{
Leandro Roser \email{leandroroser@gmail.com}
}

